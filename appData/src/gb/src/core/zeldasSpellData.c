// regex formatting to display 16 bits (1 tile) per line with:
// find: (0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],0x[0-9A-F][0-9A-F],)
// replace: $1\n

#pragma bank 5

#include <gb/gb.h>
#include "bankdata.h"
#include "zeldasInventoryCore.h"

// UINT8 *firstSpellTile = (UINT8 *)0x8000;
UINT8 *firstSpellTile = (UINT8 *)0x82c0;
UINT8 tileOffset = 0x00;

// ggbgfx sprite -o wand-tile.c .\spell-wand.png
const unsigned char spellWand[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // A
0x0C,0x0C,0x1E,0x16,0xEF,0xF1,0xEF,0x31,0xEF,0xF1,0x1E,0x16,0x0C,0x0C,0x00,0x00, // B
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 8
0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x41,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00, // 9
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 4
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 5
0x1C,0x1C,0x3E,0x22,0x7F,0x63,0x7F,0x41,0x22,0x3E,0x1C,0x1C,0x1C,0x14,0x1C,0x1C, // 6
0x1C,0x14,0x1C,0x14,0x1C,0x14,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 7
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x28,0x38,0x28,0x38,0x28, // 0
0x38,0x38,0x38,0x28,0x38,0x38,0x44,0x7C,0xFE,0x82,0xFE,0xC6,0x7C,0x44,0x38,0x38, // 1
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 2
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 3
};

void FindFirstSpellTile() BANKED
{
    while (tileOffset == 0) {
        for (UINT8 i = 0; i < 128; i++)
        {
            if (*firstSpellTile == 0xff && *(firstSpellTile + 1) == 0xc3 &&
                *(firstSpellTile + 2) == 0xff && *(firstSpellTile + 3) == 0x99 &&
                *(firstSpellTile + 4) == 0xff && *(firstSpellTile + 5) == 0x99 &&
                *(firstSpellTile + 6) == 0xff && *(firstSpellTile + 7) == 0xc1 &&
                *(firstSpellTile + 8) == 0xff && *(firstSpellTile + 9) == 0xf9 &&
                *(firstSpellTile + 10) == 0xff && *(firstSpellTile + 11) == 0x99 &&
                *(firstSpellTile + 12) == 0xff && *(firstSpellTile + 13) == 0xc3 &&
                *(firstSpellTile + 14) == 0xff && *(firstSpellTile + 15) == 0xff)
            {
                tileOffset = i;
                break;
            } else
            {
                *firstSpellTile += 16;
            }
        }
    }
}

void LoadSpell(UINT16 equipped) BANKED
{
    FindFirstSpellTile();
        set_sprite_data(tileOffset - 3, 12, spellWand);
    if (equipped == ZELDA_WEAPON_WAND) {
    }
}
